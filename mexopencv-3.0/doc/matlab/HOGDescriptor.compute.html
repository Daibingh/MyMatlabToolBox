<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <link rel="stylesheet" href="file:///D:/Program Files/MATLAB/R2014a/toolbox/matlab/helptools/private/helpwin.css">
      <title>MATLAB &#25991;&#20214;&#24110;&#21161;: cv.HOGDescriptor/compute</title>
   </head>
   <body>
      <!--Single-page help-->
      <table border="0" cellspacing="0" width="100%">
         <tr class="subheader">
            <td class="headertitle">MATLAB &#25991;&#20214;&#24110;&#21161;: cv.HOGDescriptor/compute</td>
            <td class="subheader-left">&#26597;&#30475; cv.HOGDescriptor/compute &#30340;&#20195;&#30721;</td>
            <td class="subheader-right"><a href="index.html">Index</a></td>
         </tr>
      </table>
      <div class="title">cv.HOGDescriptor/compute</div>
      <div class="helpcontent"><p>compute  Returns HOG block descriptors computed for the whole image</p>

<pre><code>descs = hog.compute(im)
descs = hog.compute(im, 'Option', optionValue, ...)
</code></pre>

<h2> Input</h2>

<ul>
<li><strong>im</strong> 8-bit 1- or 3-channel source image.</li>
</ul>

<h2> Output</h2>

<ul>
<li><strong>descs</strong> Row vectors of HOG descriptors, with the number of
columns equal to <code>hog.getDescriptorSize()</code>.</li>
</ul>

<h2> Options</h2>

<ul>
<li><strong>WinStride</strong> Window stride <code>[w,h]</code>. It must be a multiple of
block stride. Not set by default in which case it uses
<code>CellSize</code>.</li>
<li><strong>Padding</strong> Optional padding <code>[w,h]</code>. default [0,0]</li>
<li><strong>Locations</strong> cell array of 2D points <code>{[x,y],...}</code> at which
descriptors are computed. Not set by default (in which
case descriptors are computed for the whole image with a
sliding window).</li>
</ul>

<p>In case of &quot;dense&quot; descriptors (i.e <code>Locations</code> is not set), the
number of rows is equal to the number of sliding windows over
the image. Assuming zero padding, this is computed in the
following way:</p>

<pre><code>[h,w,~] = size(im);
% numel(hog.WinSize(1):hog.CellSize(1):w)
% numel(hog.WinSize(2):hog.CellSize(2):h)
windows_per_img = ([w,h] - hog.WinSize) ./ WinStride + 1
num_windows = prod(windows_per_img)
</code></pre>

<p>The windows cover the image in a top-to-bottom left-to-right
order.</p>

<p>In case of &quot;sparse&quot; descriptors (i.e <code>Locations</code> is set), the
number of rows is equal to the number of locations specified.</p>

<p>The function is mainly used to learn the classifier.</p>

<p>The computed feature vectors are compatible with the
INRIA Object Detection and Localization Toolkit
(<a href="http://pascal.inrialpes.fr/soft/olt/">http://pascal.inrialpes.fr/soft/olt/</a>).</p>
</div><!--after help --><!--seeAlso--><div class="footerlinktitle">See also</div><div class="footerlink"> <a href="HOGDescriptor.computeGradient.html">cv.HOGDescriptor/computeGradient</a></div>
      <!--Method-->
      <div class="sectiontitle">Method Details</div>
      <table class="class-details">
         <tr>
            <td class="class-detail-label">Access</td>
            <td>public</td>
         </tr>
         <tr>
            <td class="class-detail-label">Sealed</td>
            <td>false</td>
         </tr>
         <tr>
            <td class="class-detail-label">Static</td>
            <td>false</td>
         </tr>
      </table>
   </body>
</html>